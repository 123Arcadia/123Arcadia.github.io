<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蓝牙鼠标一个槽点</title>
    <link href="/2024/02/22/%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87%E4%B8%80%E4%B8%AA%E6%A7%BD%E7%82%B9/"/>
    <url>/2024/02/22/%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87%E4%B8%80%E4%B8%AA%E6%A7%BD%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>今天发现一个坑点：</p><p>​假如蓝牙鼠标连着电脑，但是在未关闭下（一转眼找不到了[只知道在附近]），一般会设置鼠标链接时禁用触摸板。</p><p><img src="/2024/02/22/%E8%93%9D%E7%89%99%E9%BC%A0%E6%A0%87%E4%B8%80%E4%B8%AA%E6%A7%BD%E7%82%B9/%E8%AE%BE%E7%BD%AE%E8%A7%A6%E6%91%B8%E6%9D%BF.jpg" alt="设置触摸板"></p><p>这时只能使用键盘关闭该设置，才回复触摸板使用</p><p><code>win + i</code>: 打开设置界面</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava学习记录</title>
    <link href="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava学习记录"><a href="#Guava学习记录" class="headerlink" title="Guava学习记录"></a>Guava学习记录</h1><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%8E%A5%E5%8F%A3.png" alt="常用接口"></p><h4 id="Multiset可重复集合"><a href="#Multiset可重复集合" class="headerlink" title="Multiset可重复集合"></a>Multiset可重复集合</h4><p>1、 <code>Multiset</code>，它支持添加多个相同的元素，其中成员可以出现不止一次。</p><ul><li>Multiset 相当于 Set，区别在于 Multiset 可添加相同的元素，它的内部使用一个 HashMap 来维护，</li></ul><p>2、Multiset 也有自己的实现类，常用的有 <code>HashMultiset</code>、<code>LinkedHashMultiset</code>、<code>TreeMultiset</code> 等，<code>HashMultiset</code> 、<code>TreeMultiset</code> 是<strong>无序</strong>的，<code>LinkedHashMultiset</code> 是有序的，操作完全同理 JDK 的 HashSet、TreeSet、LinkedHashSet。</p><h4 id="Multimap-多重映射"><a href="#Multimap-多重映射" class="headerlink" title="Multimap 多重映射"></a>Multimap 多重映射</h4><p>1、使用Map&lt;K、List<V>&gt; 或 Map&lt;K、Set<V>&gt;，Guava 的 Multimap 框架使处理从键到多个值的映射变得容易，多重映射是将键与任意多个值关联的一种通用方法。</p><p>2、从概念上讲，有两种方法可以将多重映射视为从单个键到单个值的映射的集合</p><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/mutilmap%E5%AE%9E%E7%8E%B0.png" alt="mutilmap实现"></p><blockquote><p>除了不可变的实现之外，每个实现都支持空键和值。并不是所有的实现都是作为一个<code>Map&lt;K，Collection&lt;V&gt;&gt;</code>实现的（特别是一些Multimap实现使用自定义哈希表来最小化开销)</p></blockquote><h4 id="BiMap-双向映射"><a href="#BiMap-双向映射" class="headerlink" title="BiMap 双向映射"></a>BiMap 双向映射</h4><p>值映射回键的传统方法是维护两个独立的映射，并使它们保持同步</p><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/BitMap%E5%AE%9E%E7%8E%B0.png" alt="BitMap实现"></p><h4 id="Table-表结构数据"><a href="#Table-表结构数据" class="headerlink" title="Table 表结构数据"></a>Table 表结构数据</h4><ul><li><code>HashBasedTable</code>：基本上是由 HashMap&lt;R，HashMap&lt;C，V&gt;&gt; 支持的。</li><li><code>TreeBasedTable</code>：基本上是由 TreeMap&lt;R，TreeMap&lt;C，V&gt;&gt; 支撑的。</li><li><code>ImmutableTable</code></li><li><code>ArrayTable</code>：要求在构造时指定行和列的完整范围，但在表密集时由二维数组支持以提高速度和内存效率，ArrayTable的工作原理与其他实现有些不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * HashBasedTable 内部提供 Map&lt;R, Map&lt;C, V&gt;&gt; 结构用于存储数据库 table 结构的数据 &lt;p&gt;</span><br><span class="hljs-comment">     * 此实现不同步，如果多个线程访问此表，必须在外部进行同步 &lt;p&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hashBasedTable</span><span class="hljs-params">()</span> &#123;<br>        HashBasedTable&lt;Object, Object, Object&gt; hashBasedTable = HashBasedTable.create();<br>        hashBasedTable.put(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;展护卫&quot;</span>);<br>        hashBasedTable.put(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>);<br>        hashBasedTable.put(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">88898.78</span>);<br><br>        hashBasedTable.put(<span class="hljs-string">&quot;1002&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;马汉&quot;</span>);<br>        hashBasedTable.put(<span class="hljs-string">&quot;1002&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;43&quot;</span>);<br>        hashBasedTable.put(<span class="hljs-string">&quot;1002&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">56898.78</span>);<br><br>        <span class="hljs-comment">//获取每一行的主键：rowKeySet=[1001, 1002]</span><br>        Set&lt;Object&gt; rowKeySet = hashBasedTable.rowKeySet();<br>        System.out.println(<span class="hljs-string">&quot;rowKeySet=&quot;</span> + rowKeySet);<br><br>        <span class="hljs-comment">//获取列名称：columnKeySet=[name, age, price]</span><br>        Set&lt;Object&gt; columnKeySet = hashBasedTable.columnKeySet();<br>        System.out.println(<span class="hljs-string">&quot;columnKeySet=&quot;</span> + columnKeySet);<br><br>        Collection&lt;Object&gt; values = hashBasedTable.values();<br>        System.out.println(<span class="hljs-string">&quot;values = &quot;</span> + values);<br>        <span class="hljs-comment">//values = [展护卫, 33, 88898.78, 马汉, 43, 56898.78]</span><br><br>        <span class="hljs-comment">//hashBasedTable=&#123;1001=&#123;name=展护卫, age=33, price=88898.78&#125;, 1002=&#123;name=马汉, age=43, price=56898.78&#125;&#125;</span><br>        System.out.println(<span class="hljs-string">&quot;hashBasedTable=&quot;</span> + hashBasedTable);<br><br>        <span class="hljs-comment">//根据主键获取单条数据：row=&#123;name=展护卫, age=33, price=88898.78&#125;</span><br>        Map&lt;Object, Object&gt; row = hashBasedTable.row(<span class="hljs-string">&quot;1001&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;row=&quot;</span> + row);<br><br>        <span class="hljs-comment">//根据列名获取所有记录的值：name=&#123;1001=展护卫, 1002=马汉&#125;</span><br>        Map&lt;Object, Object&gt; name = hashBasedTable.column(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br><br>        <span class="hljs-comment">//根据主键以及列名获取字段值：name1=展护卫</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> hashBasedTable.get(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name1=&quot;</span> + name1);<br><br>        <span class="hljs-comment">//遍历每个单元格</span><br>        Set&lt;Table.Cell&lt;Object, Object, Object&gt;&gt; cellSet = hashBasedTable.cellSet();<br>        <span class="hljs-keyword">for</span> (Table.Cell&lt;Object, Object, Object&gt; cell : cellSet) &#123;<br>            System.out.println(<span class="hljs-string">&quot;rowKey=&quot;</span> + cell.getRowKey() + <span class="hljs-string">&quot; - &quot;</span> + cell.getColumnKey() + <span class="hljs-string">&quot; - &quot;</span> + cell.getValue());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="istenableFuture-不推荐"><a href="#istenableFuture-不推荐" class="headerlink" title="istenableFuture(不推荐)"></a>istenableFuture(不推荐)</h4><p>顾名思义就是可以监听的Future，是对java原生Future的扩展增强</p><h4 id="ClassToInstanceMap-类型映射到实例"><a href="#ClassToInstanceMap-类型映射到实例" class="headerlink" title="ClassToInstanceMap 类型映射到实例"></a>ClassToInstanceMap 类型映射到实例</h4><p>1、有时 key 并不是单一的类型，而是多种类型，Guava 为此提供了 <code>ClassToInstanceMap</code>，key 可以是多种类型，value 是此类型的实例。</p><p>2、<code>ClassToInstanceMap</code> 的实现有：<code>MutableClassToInstanceMap</code> 和 <code>ImmutableClassToInstanceMap</code> 。</p><h4 id="JDK集合辅助工具类"><a href="#JDK集合辅助工具类" class="headerlink" title="JDK集合辅助工具类"></a>JDK集合辅助工具类</h4><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/jdk%E8%BE%85%E5%8A%A9%E9%9B%86%E5%90%88utils.png" alt="jdk辅助集合utils"></p><h4 id="JDK-基本类型辅助工具类"><a href="#JDK-基本类型辅助工具类" class="headerlink" title="JDK 基本类型辅助工具类"></a>JDK 基本类型辅助工具类</h4><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/jdk%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BE%85%E5%8A%A9utils.png" alt="jdk基本类型辅助utils"></p><h4 id="JDK-字符串辅助工具类"><a href="#JDK-字符串辅助工具类" class="headerlink" title="JDK 字符串辅助工具类"></a>JDK 字符串辅助工具类</h4><ul><li><p><code>Strings</code> 类</p></li><li><p><code>Joiner</code> 是连接器，用于连接 <code>java.lang.Iterable</code>、<code>java.util.Iterator</code>、<code>java.lang.Object[] </code>中的元素。</p></li><li><p><code>Splitter</code> 是分割器，用于分割字符序列 <code>java.lang.CharSequence</code>。</p></li><li><p><code>CharMatcher</code> 字符匹配器，用于匹配字符，可以将 CharMatcher 视为代表一类特定的字符，如数字或空白。注意：CharMatcher 只处理 char 值。</p></li></ul><h4 id="Stopwatch-秒表"><a href="#Stopwatch-秒表" class="headerlink" title="Stopwatch 秒表"></a><strong>Stopwatch 秒表</strong></h4><p>1、google 的秒表 Stopwatch 相比 <code>Spring framewrk core</code> 包 和 <code>apache commons lang3</code> 包的秒表是最方便使用的。</p><p>2、此类不是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Stopwatch createStarted()：创建（并启动）一个新的秒表，使用 System#nanoTime 来作为其时间源。</span><br><span class="hljs-comment">  * Stopwatch createUnstarted()：创建（但不启动）一个新的秒表，使用 System#nanoTime 来作为其时间源。</span><br><span class="hljs-comment">  * long elapsed(TimeUnit desiredUnit)：返回此秒表上显示的当前已用时间，以所需的时间单位表示，任何分数向下舍入</span><br><span class="hljs-comment">  * boolean isRunning()：如果已在此秒表上调用start（）&#125;，并且自上次调用start（）以来未调用stop（），则返回true</span><br><span class="hljs-comment">  * Stopwatch reset()：将此秒表的运行时间设置为零，并将其置于停止状态。</span><br><span class="hljs-comment">  * Stopwatch start()：启动秒表,如果秒表已经在运行，则 IllegalStateException</span><br><span class="hljs-comment">  * Stopwatch stop()：停止秒表，将来的读取将返回到目前为止经过的固定持续时间。</span><br><span class="hljs-comment">  * tring toString()：返回当前运行时间的字符串表示形式，比如 2.588 s，106.8 ms</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStopwatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>     <span class="hljs-type">Stopwatch</span> <span class="hljs-variable">stopwatch</span> <span class="hljs-operator">=</span> Stopwatch.createStarted();<br> <br>     <span class="hljs-type">int</span> <span class="hljs-variable">nextInt</span> <span class="hljs-operator">=</span> secureRandom.nextInt(<span class="hljs-number">2000</span>);<br>     System.out.println(<span class="hljs-string">&quot;任务1预算耗时：&quot;</span> + nextInt);<span class="hljs-comment">//任务1预算耗时：81</span><br>     TimeUnit.MILLISECONDS.sleep(nextInt);<br>     System.out.println(<span class="hljs-string">&quot;\t任务1实际耗时：&quot;</span> + stopwatch.elapsed(TimeUnit.MILLISECONDS) + <span class="hljs-string">&quot;(毫秒)&quot;</span>);<span class="hljs-comment">// 任务1实际耗时：563(毫秒)</span><br> <br>     stopwatch.reset().start();<br>     nextInt = secureRandom.nextInt(<span class="hljs-number">4000</span>);<br>     System.out.println(<span class="hljs-string">&quot;任务2预算耗时：&quot;</span> + nextInt);<span class="hljs-comment">//任务2预算耗时：1591</span><br>     TimeUnit.MILLISECONDS.sleep(nextInt);<br>     System.out.println(<span class="hljs-string">&quot;\t任务2实际耗时：&quot;</span> + stopwatch.toString());<span class="hljs-comment">// 任务2实际耗时：1.592 s</span><br> <br>     stopwatch.reset().start();<br>     nextInt = secureRandom.nextInt(<span class="hljs-number">3000</span>);<br>     System.out.println(<span class="hljs-string">&quot;任务3预计耗时：&quot;</span> + nextInt);<span class="hljs-comment">//任务3预计耗时：1964</span><br>     TimeUnit.MILLISECONDS.sleep(nextInt);<br>     System.out.println(<span class="hljs-string">&quot;\t任务3实际耗时：&quot;</span> + stopwatch.stop().toString());<span class="hljs-comment">// 任务3实际耗时：1.965 s</span><br> &#125;<br></code></pre></td></tr></table></figure><h5 id="RateLimiter-限速器-限流器-为什么不用延迟调度？"><a href="#RateLimiter-限速器-限流器-为什么不用延迟调度？" class="headerlink" title="RateLimiter 限速器&#x2F;限流器(为什么不用延迟调度？)"></a>RateLimiter 限速器&#x2F;限流器(为什么不用延迟调度？)</h5><p>例子:</p><p>在创建RateLimiter时，设置了RateLimiter的PPS&#x3D;2.0(PPS&#x3D;Permit per second）)，<br> 而之后每次执行一个任务之前，进行一次acquire（），<br> 一次acquire消耗一个permit，<br> 那么可以计算出任务的执行速度是 <strong>2个&#x2F;秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2.0</span>); <span class="hljs-comment">// rate is &quot;2 permits per second&quot;</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">submitTasks</span><span class="hljs-params">(List&lt;Runnable&gt; tasks, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Runnable task : tasks) &#123;<br>        rateLimiter.acquire(); <span class="hljs-comment">// may wait</span><br>        executor.execute(task);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果要对QPS进行限制，那么Permit &#x3D; Query，一次Query消耗一个Permit就能达到效果</p><p>如果对文件网络IO进行限制，那么Permit &#x3D;  Size of Package，每次包大小越大消耗的Permit越多</p><p>如果要对请求时长进行限制，那么Permit &#x3D; Time Cost of Query</p></blockquote><p>如下代码就是对网络IO进行限制，可以看出RateLimiter的PPS为5000，那么可以推断出<br>该程序的IO速度为 5000byte&#x2F;s</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">5000.0</span>); <br><span class="hljs-comment">// rate = 5000 permits per second</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">submitPacket</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] packet)</span> &#123;<br>    rateLimiter.acquire(packet.length);<br>    networkService.send(packet);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/02/13/Guava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/test%E4%BE%8B.png" alt="test例"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>easyExcel简短总结</title>
    <link href="/2024/02/12/easyExcel%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/12/easyExcel%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="easyExcel"><a href="#easyExcel" class="headerlink" title="easyExcel"></a>easyExcel</h1><blockquote><p>参考:<a href="https://blog.csdn.net/qq_41958629/article/details/132101993">https://blog.csdn.net/qq_41958629/article/details/132101993</a></p></blockquote><ul><li><code>@ExcelIgnore</code>：默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</li><li><code>@ExcelIgnoreUnannotated</code>：添加玩<code>@ExcelIgnoreUnannotated</code>注解后，只有添加了<code>@ExcelProperty</code>注解的属性才会被写入Excel中。</li><li><code>@ExcelProperty</code></li></ul><p><img src="/2024/02/12/easyExcel%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ExcelProperty%E8%A7%A3%E9%87%8A.png" alt="@ExcelProperty解释"></p><p>使用字段名作为默认表头</p><ul><li>设置多个表头：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoData</span> &#123;<br>    <span class="hljs-meta">@ExcelProperty(value = &#123;&quot;主题1&quot;, &quot;字符串标题&quot;&#125;, index = 0)</span><br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-meta">@ExcelProperty(value = &#123;&quot;主题1&quot;, &quot;日期标题&quot;&#125;, index = 1)</span><br>    <span class="hljs-keyword">private</span> Date date;<br><br>    <span class="hljs-meta">@ExcelProperty(value = &#123;&quot;主题2&quot;, &quot;数字标题&quot;&#125;, index = 3)</span><br>    <span class="hljs-keyword">private</span> Double doubleData;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/02/12/easyExcel%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E8%A1%A8%E6%A0%BCindex%E6%8C%87%E5%AE%9A%E8%A1%A8%E5%A4%B4.png" alt="表格index指定表头"></p><p><img src="/../easyExcel%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.assets/u=3539595421,754041626&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto.jpeg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java排查耗时代码</title>
    <link href="/2024/02/12/java%E6%8E%92%E6%9F%A5%E8%80%97%E6%97%B6%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/02/12/java%E6%8E%92%E6%9F%A5%E8%80%97%E6%97%B6%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="java排查耗时代码的几种方式"><a href="#java排查耗时代码的几种方式" class="headerlink" title="java排查耗时代码的几种方式"></a>java排查耗时代码的几种方式</h1><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack是jdk自带的堆栈跟踪工具</p><p>首先，我们用<code>ps -ef|grep java</code>命令列出正在运行的java进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ps -ef|grep java</span><br>root        33    32 67 21:52 tty2     00:00:10 java -jar xxx.jar<br>root       101    11  0 21:52 pts/0    00:00:00 grep --color=auto java<br></code></pre></td></tr></table></figure><p><code>jstack -l [pid号]</code>命令打印线程运行情况</p><p><code>ps p  [pid号] -L -o pcpu,pid,tid,time,tname,cmd</code>打印出线程使用cpu的情况</p><p>打印结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">jstack -l 33</span><br>Full thread dump OpenJDK 64-Bit Server VM (17.0.2+8-86 mixed mode, sharing):<br><br>Threads class SMR info:<br>_java_thread_list=0x00007f3658001890, length=12, elements=&#123;<br>0x00007f369c023f10, 0x00007f369c1739b0, ...<br>&#125;<br><br>&quot;main&quot; #1 prio=5 os_prio=0 cpu=90140.00ms elapsed=98.18s tid=0x00007f369c023f10 nid=0x22 runnable  [0x00007f36a12fe000]<br>   java.lang.Thread.State: RUNNABLE<br>        at org.rocksdb.RocksDB.get(Native Method)<br>        at org.rocksdb.RocksDB.get(RocksDB.java:1965)<br>        at org.wowtools.giscat.vector.rocksrtree.TreeTransaction.get(TreeTransaction.java:74)<br>        at org.wowtools.giscat.vector.rocksrtree.TreeBuilder.getLeaf(TreeBuilder.java:186)<br>        ...<br><br>   Locked ownable synchronizers:<br>        - None<br><br>&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 cpu=0.00ms elapsed=97.06s tid=0x00007f369c1739b0 nid=0x29 waiting on condition  [0x00007f367955e000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.lang.ref.Reference.waitForReferencePendingList(java.base@17.0.2/Native Method)<br>        at java.lang.ref.Reference.processPendingReferences(java.base@17.0.2/Reference.java:253)<br>        at java.lang.ref.Reference$ReferenceHandler.run(java.base@17.0.2/Reference.java:215)<br><br>   Locked ownable synchronizers:<br>        - None<br><br>...<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ps p 33 -L -o pcpu,pid,tid,time,tname,cmd</span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">CPU   PID   TID     TIME TTY      CMD</span><br>91.9    33    33 00:01:02 tty2     /mydata/java/jdk-17/bin/java<br>87.9    33    34 00:00:59 tty2     /mydata/java/jdk-17/bin/java<br> 0.0    33    35 00:00:00 tty2     /mydata/java/jdk-17/bin/java<br> 0.0    33    36 00:00:00 tty2     /mydata/java/jdk-17/bin/java<br> ...<br><br></code></pre></td></tr></table></figure><p>现在我们知道了34号线程是最忙的，占了87.9%的CPU（33是主线程看不出什么内容），然后把34转为16进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf &quot;0x%x\n&quot;  34<br><span class="hljs-meta prompt_"># </span><span class="language-bash">0x22</span><br></code></pre></td></tr></table></figure><p>最后，我们去查找<code>jstack -l</code> 33的输出里找关键字<strong>0x22</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;main&quot; #1 prio=5 os_prio=0 cpu=90140.00ms elapsed=98.18s tid=0x00007f369c023f10 nid=0x22 runnable  [0x00007f36a12fe000]<br>   java.lang.Thread.State: RUNNABLE<br>        at org.rocksdb.RocksDB.get(Native Method)<br>        at org.rocksdb.RocksDB.get(RocksDB.java:1965)<br>        at org.wowtools.giscat.vector.rocksrtree.TreeTransaction.get(TreeTransaction.java:74)<br>        at org.wowtools.giscat.vector.rocksrtree.TreeBuilder.getLeaf(TreeBuilder.java:186)<br>        ...<br><br></code></pre></td></tr></table></figure><p>频繁地去RocksDB里get数据，导致性能过低</p><hr><h3 id="使用阿尔萨斯Arthas"><a href="#使用阿尔萨斯Arthas" class="headerlink" title="使用阿尔萨斯Arthas"></a>使用阿尔萨斯Arthas</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2024/02/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>基本命令了解</strong>：</p><ol><li><p>hexo -v            &#x2F;&#x2F;查看版本        </p></li><li><p>hexo init        &#x2F;&#x2F;初始化一个项目</p></li><li><p>cnpm install        </p></li><li><p>hexo clean        &#x2F;&#x2F;清理生成的文件</p></li><li><p>hexo g            &#x2F;&#x2F;生成静态网页文件，g是generate的缩写</p></li><li><p>hexo s            &#x2F;&#x2F;运行到服务器端，s是server的缩写</p></li><li><p>hexo d            &#x2F;&#x2F;部署到远端GitHub, d是deploy的缩写</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs she">// 一行<br>hexo clean &amp; hexo g -d<br></code></pre></td></tr></table></figure><ol start="8"><li><p>hexo s -p 5000    &#x2F;&#x2F;在4000端口被占用的时候，修改指定端口</p></li><li><p>cnpm uninstall hexo-cli -g    &#x2F;&#x2F;卸载hexo</p></li><li><p>npm install hexo -g #安装Hexo</p></li><li><p>npm update hexo -g #升级   </p></li><li><p><code>hexo n &quot;标题&quot; == hexo new &quot;标题&quot;</code> #新建文章</p></li><li><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器</p></li><li><p>hexo server -s #静态模式</p></li><li><p>hexo server -p 5000 #更改端口</p></li><li><p>hexo server -i 192.168.1.1 #自定义 IP</p></li><li><p>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2024/02/08/%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/02/08/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><strong>hello, This is thr First!</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![缅因猫](缅因猫.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/02/08/%E6%B5%8B%E8%AF%95/%E7%BC%85%E5%9B%A0%E7%8C%AB.jpg" alt="缅因猫"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;% asset_img 图片文件名 图片加载失败的描述 %&#125;<br>或<br>&lt;img src=&quot;https://alexcld.com/images/pengyuyan.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;<br></code></pre></td></tr></table></figure><img src="/2024/02/08/%E6%B5%8B%E8%AF%95/%E7%BC%85%E5%9B%A0%E7%8C%AB.jpg" class="" title="缅因猫加载失败"><p>缺点：图片就会靠在左侧，大小也不由自己决定</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;img src=&quot;/img/缅因猫.jpg&quot; style=&quot;zoom:80%&quot; /&gt; <br></code></pre></td></tr></table></figure><img src="/img/缅因猫.jpg" style="zoom:80%" /> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![风铃-第二种引用](fengling)<br></code></pre></td></tr></table></figure><p><img src="/fengling" alt="风铃-第二种引用"></p><p><strong>例子</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![下雨](preview)<br></code></pre></td></tr></table></figure><p><img src="/preview" alt="下雨"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![下雨](preview.jpg)<br></code></pre></td></tr></table></figure><p><img src="/2024/02/08/%E6%B5%8B%E8%AF%95/preview.jpg" alt="下雨"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">![风景](风景.png)<br></code></pre></td></tr></table></figure><p><img src="/2024/02/08/%E6%B5%8B%E8%AF%95/%E9%A3%8E%E6%99%AF.png" alt="风景"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/08/hello-world/"/>
    <url>/2024/02/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
